time_length(normalDate_later - normalDate, "day")
time_length(leapYear_later - leapYear, "days") # Note this is 3 days because of leap year
time_length(enterDST_later - enterDST, "days")
time_length(exitDST_later - exitDST, "days")
## With interval
# second, minute, hour, day, week, month, bimonth, quarter, season, halfyear, year
# Note the order is flipped for intervals, with starting date first
time_length(interval(normalDate, normalDate_later), "seconds")
time_length(interval(normalDate, normalDate_later), "minutes")
time_length(interval(normalDate, normalDate_later), "hours")
time_length(interval(normalDate, normalDate_later), "days")
time_length(interval(leapYear, leapYear_later), "days") # Note this is 3 days because of leap year
time_length(interval(enterDST, enterDST_later), "days")
time_length(interval(exitDST, exitDST_later), "days")
## With Base R
# secs, mins, hours, days, months, years
as.numeric(normalDate_later - normalDate, units = "secs")
as.numeric(normalDate_later - normalDate, units = "mins")
as.numeric(normalDate_later - normalDate, units = "hours")
as.numeric(normalDate_later - normalDate, units = "days")
as.numeric(leapYear_later - leapYear, units = "days") # Note this is 3 days because of leap year
as.numeric(enterDST_later - enterDST, units = "days")
as.numeric(exitDST_later - exitDST, units = "days")
# Chunk 17
normalDate <- as_date("2014-02-28")
mday(normalDate)
wday(normalDate)
wday(normalDate, label = TRUE)
wday(normalDate, label = TRUE, abbr = FALSE)
month(normalDate)
month(normalDate, label = TRUE)
month(normalDate, label = TRUE, abbr = FALSE)
year(normalDate)
# Chunk 18
normalDate <- as_date("2014-02-28")
## Round down
floor_date(normalDate)
# Careful, because the default rounding unit is "seconds",
# which converts date to POSIXct, with UTC timezone
str(floor_date(normalDate))
tz(floor_date(normalDate))
# Choices for explicit rounding
# second, minute, hour, day, week, month, bimonth, quarter, season, halfyear, year
floor_date(normalDate, unit = "month")
floor_date(normalDate, unit = "year")
## Round up
ceiling_date(normalDate, unit = "month")
ceiling_date(normalDate, unit = "year")
## Round
round_date(normalDate, unit = "month")
round_date(normalDate, unit = "year")
# Base R
# secs, mins, hours, days, months, years
round.Date(normalDate, "month")
round(normalDate)
# Chunk 19
auditStart <- as_date("2016-05-01") # Notice this is a leap year
auditEnd <- as_date("2017-04-30")
## WARNING: This works here because we are only working with dates,
## but it will cause headaches when time is involved
auditStart - months(2)
auditEnd + months(2)
## CORRECT
auditStart %m-% months(2)
auditEnd %m+% months(2)
# Chunk 20
# Chunk 21
# Chunk 22
time_length(normalDate_later - normalDate, "quarter")
## With Base R
# Choices: secs, mins, hours, days, months, years
as.numeric(normalDate_later - normalDate, units = "sec")
# Chunk 1
## Setting global chunk options
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE)
# Chunk 2
library(wso)
wso::util.packs(packs = c("tidyverse", "readxl", "anytime"))
wso::util.settings()
# Chunk 3
if (.Platform$OS.type == "windows") {
stop("Please define your directory for Windows, then delete this line.")
# baseDir <- "G:\Team Drives\WSO USA - Projects\000 - Project"
} else {
baseDir <- "~/Desktop/GitHub/code-book/r"
}
dataDir <- file.path(baseDir, "_data")
# Chunk 4
# Most flexible
as_date("2011-06-04")
as_date("June.4.11", format = "%B.%d.%y", tz = "")
str(as_date("2011-06-04"))
# Shortcuts
ymd("2011-06-04")
mdy("06042011")
dmy("04/06/2011")
str(ymd("2011-06-04"))
# Not Lubridate, but still from tidyverse (readr)
parse_date("2011-06-04")
parse_date("June.4.11", format = "%B.%d.%y")
# Compare to Base R
# Normal date
as.Date("2011-06-04")
as.Date("June.4.11", format = "%B.%d.%y")
str(as.Date("2011-06-04"))
# Invalid day
as.Date("2011-02-29")
as_date("2011-02-29")
# Chunk 5
# Standard (i.e. uses integers)
make_date("2011", "06", "02")
make_date(2011, 6, 2)
str(make_date("2011", "06", "02"))
# Need to parse from string
make_date(2011, match("Jun", month.abb), 4)
make_date(2011, match("June", month.name), 4)
# Compare to Base R
as.Date(paste("2011", "06", "04", sep = "-"))
as.Date(paste(2011, 6, 4, sep = "-"))
str(paste("2011", "06", "04", sep = "-"))
as.Date(paste(2011, match("Jun", month.abb), 4, sep = "-"))
as.Date(paste(2011, match("June", month.name), 4, sep = "-"))
# Chunk 6
## Get today's date
today()
# Compare to Base R
Sys.Date()
# Chunk 7
# grade	 class	 date
# A	     2	     10/7/17
# A 	 1	     2/11/15
# D	     1	     11/3/17
simpleDatesCSV <- read_csv(file.path(dataDir, "dates-simple.csv"),
col_types = cols(
grade = col_character(),
class = col_number(),
date = col_date(format = "")
)
)
simpleDatesCSV[1:3,]
# Chunk 8
# grade	 class	 date
# A	     2	     June.4.11
# A	     1	     June.4.12
# D	     1	     June.4.13
altDatesCSV <- read_csv(file.path(dataDir, "dates-alt.csv"),
col_types = cols(
grade = col_character(),
class = col_number(),
date = col_date(format = "%B.%d.%y")
)
)
altDatesCSV[1:3,]
# Chunk 9
# grade	  class	  date
# A	      2	      43015
# A	      1	      9.17.2016
# D	      1	      6/6/17
## Fails initial import
mixedDatesCSV <- read_csv(file.path(dataDir, "dates-mixed.csv"),
col_types = cols(
grade = col_character(),
class = col_number(),
date = col_date(format = "")
)
)
## Try again, but bring in the date column as a character...
mixedDatesCSV <- read_csv(file.path(dataDir, "dates-mixed.csv"),
col_types = cols(
grade = col_character(),
class = col_double(),
date = col_character()
)
)
## ... then try to parse your dates with a case_when syntax. Warning, you will see warnings, so you
## need to spot check the results to make sure the dates were parsed correctly.
mixedDatesCSV <- mixedDatesCSV %>%
mutate(
date = case_when(
!is.na(parse_date(date, "%m.%d.%Y")) ~ parse_date(date, "%m.%d.%Y"),
!is.na(parse_date(date, "%m/%d/%y")) ~ parse_date(date, "%m/%d/%y"),
TRUE ~ as_date(as.numeric(date), origin = "1899-12-30")
)
)
mixedDatesCSV[1:3,]
# Chunk 10
# Chunk 11
# grade	 class	 date
# A	     2	     10/7/17
# A 	 1	     2/11/15
# D	     1	     11/3/17
simpleDatesXL <- read_excel(file.path(dataDir, "dates-simple.xlsx"),
col_types = c(
"text",     # grade
"numeric",  # class
"date"      # date
)
)
# Comes out as date time, so need to coerce
simpleDatesXL <- simpleDatesXL %>%
mutate(
date = as_date(date)
)
simpleDatesXL[1:3,]
# Chunk 12
# grade	 class	 date
# A	     2	     June.4.11
# A	     1	     June.4.12
# D	     1	     June.4.13
altDatesXL <- read_excel(file.path(dataDir, "dates-alt.xlsx"),
col_types = c(
"text",     # grade
"numeric",  # class
"date"      # date
)
)
altDatesXL[1:3,]
# Chunk 13
# grade	  class	  date
# A	      2	      43015
# A	      1	      9.17.2016
# D	      1	      6/6/17
## Fails initial import
mixedDatesXL <- read_excel(file.path(dataDir, "dates-mixed.xlsx"),
col_types = c(
"text",     # grade
"numeric",  # class
"date"      # date
)
)
## Result
# grade	  class	  date
# A	      2	      2017-10-07
# A	      1	      NA
# D	      1	      2017-06-06
## Try again, but bring in the date column as a character...
mixedDatesXL <- read_excel(file.path(dataDir, "dates-mixed.xlsx"),
col_types = c(
"text",     # grade
"numeric",  # class
"text"      # date
)
)
## ... then try to parse your dates with a case_when syntax. Warning, you will see warnings, so you
## need to spot check the results to make sure the dates were parsed correctly.
mixedDatesXL <- mixedDatesXL %>%
mutate(
date = case_when(
!is.na(parse_date(date, "%m.%d.%Y")) ~ parse_date(date, "%m.%d.%Y"),
!is.na(parse_date(date, "%m/%d/%y")) ~ parse_date(date, "%m/%d/%y"),
TRUE ~ as_date(as.numeric(date), origin = "1899-12-30")
)
)
mixedDatesXL[1:3,]
# Chunk 14
# Chunk 15
normalDate <- as_date("2014-02-28")
leapYear <- as_date("2016-02-28")
enterDST <- as_date("2019-03-09")
exitDST <- as_date("2019-11-02")
normalDate + days(1)
normalDate + weeks(1)
normalDate + months(1)
normalDate + years(1)
normalDate + dyears(1) # Notice this gives us the same result as above because we are not in a leap year. See next group.
leapYear + days(1)
leapYear + weeks(1)
leapYear + months(1)
leapYear + years(1)
leapYear + dyears(1) # Notice this only gets us part of the way there because we added an exact duration of the average year, which is less than the 366 days in this leap year
enterDST + days(1)
enterDST + weeks(1)
enterDST + months(1)
enterDST + years(1)
exitDST + days(1)
exitDST + weeks(1)
exitDST + months(1)
exitDST + years(1)
# Chunk 16
normalDate_later <- as_date("2014-03-02") # from 2014-02-28
leapYear_later <- as_date("2016-03-02") # from 2016-02-28
enterDST_later <- as_date("2019-03-11") # from 2019-03-09
exitDST_later <- as_date("2019-11-04") # from 2019-11-02
## With arithmetic
# Choices: second, minute, hour, day, week
# WARNING: Do not use units higher than week because they have ambiguous lengths.
# For example, one month may be 28, 29, 30, or 31 days long.
time_length(normalDate_later - normalDate, "second")
time_length(normalDate_later - normalDate, "minute")
time_length(normalDate_later - normalDate, "hour")
time_length(normalDate_later - normalDate, "day")
time_length(leapYear_later - leapYear, "day") # Note this is 3 days because of leap year
time_length(enterDST_later - enterDST, "day")
time_length(exitDST_later - exitDST, "day")
## With interval
# Note the order is flipped for intervals, with starting date first
time_length(interval(normalDate, normalDate_later), "second")
time_length(interval(normalDate, normalDate_later), "minute")
time_length(interval(normalDate, normalDate_later), "hour")
time_length(interval(normalDate, normalDate_later), "day")
time_length(interval(leapYear, leapYear_later), "day") # Note this is 3 days because of leap year
time_length(interval(enterDST, enterDST_later), "day")
time_length(interval(exitDST, exitDST_later), "day")
## With Base R
# Choices: secs, mins, hours, days, months, years
as.numeric(normalDate_later - normalDate, units = "secs")
as.numeric(normalDate_later - normalDate, units = "mins")
as.numeric(normalDate_later - normalDate, units = "hours")
as.numeric(normalDate_later - normalDate, units = "days")
as.numeric(leapYear_later - leapYear, units = "days") # Note this is 3 days because of leap year
as.numeric(enterDST_later - enterDST, units = "days")
as.numeric(exitDST_later - exitDST, units = "days")
# Chunk 17
normalDate <- as_date("2014-02-28")
mday(normalDate)
wday(normalDate)
wday(normalDate, label = TRUE)
wday(normalDate, label = TRUE, abbr = FALSE)
month(normalDate)
month(normalDate, label = TRUE)
month(normalDate, label = TRUE, abbr = FALSE)
year(normalDate)
# Chunk 18
normalDate <- as_date("2014-02-28")
## Round down
floor_date(normalDate)
# Careful, because the default rounding unit is "seconds",
# which converts date to POSIXct, with UTC timezone
str(floor_date(normalDate))
tz(floor_date(normalDate))
# Choices for explicit rounding
# second, minute, hour, day, week, month, bimonth, quarter, season, halfyear, year
floor_date(normalDate, unit = "month")
floor_date(normalDate, unit = "year")
## Round up
ceiling_date(normalDate, unit = "month")
ceiling_date(normalDate, unit = "year")
## Round
round_date(normalDate, unit = "month")
round_date(normalDate, unit = "year")
# Base R
# secs, mins, hours, days, months, years
round.Date(normalDate, "month")
round(normalDate)
# Chunk 19
auditStart <- as_date("2016-05-01") # Notice this is a leap year
auditEnd <- as_date("2017-04-30")
## WARNING: This works here because we are only working with dates,
## but it will cause headaches when time is involved
auditStart - months(2)
auditEnd + months(2)
## CORRECT
auditStart %m-% months(2)
auditEnd %m+% months(2)
# Chunk 20
# Chunk 21
# Chunk 22
# Base R
# secs, mins, hours, days, months, years
round.Date(normalDate, "secs")
# Base R
# secs, mins, hours, days, months, years
round(normalDate, "secs")
# Base R
# secs, mins, hours, days, months, years
round(as.POSIXct(normalDate), "secs")
## Base R
# Only available for POSIXct, so if you must do this with your
# date object in base R, coerce it
round(as.POSIXct(normalDate), "secs")
## Base R
# Only available for POSIXct, so if you must do this with your
# date object in base R, coerce it
round(as.POSIXct(normalDate), "sec")
## With Base R
# Choices: secs, mins, hours, days, months, years
as.numeric(normalDate_later - normalDate, units = "secs")
## With Base R
# Choices: secs, mins, hours, days, months, years
as.numeric(normalDate_later - normalDate, units = "sec")
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "min")
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "hours")
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "day")
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "days")
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "months")
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "month")
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "year")
truncate(as.POSIXct(normalDate), "month")
trunc(as.POSIXct(normalDate), "month")
normalDate
## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: sec, mins, hours, days, months, years
round(as.POSIXct(normalDate), "month")
trunc(as.POSIXct(normalDate), "month")
round(as.POSIXct(normalDate + days(5)), "month")
## General round and round down
round(as.POSIXct(normalDate), "months")
trunc(as.POSIXct(normalDate), "months")
# Chunk 1
## Setting global chunk options
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE)
# Chunk 2
library(wso)
library(tidyverse)
wso::util.settings()
# Chunk 3
if (.Platform$OS.type == "windows") {
stop("Please define your directory for Windows, then delete this line.")
# baseDir <- "G:\Team Drives\WSO USA - Projects\000 - Project"
} else {
baseDir <- "~/Desktop/GitHub/code-book/r"
}
dataDir <- file.path(baseDir, "_data")
list.files(dataDir)
?list.files
list.dirs(dataDir)
list.files(dataDir, recursive = TRUE)
list.files(dataDir, full.names = TRUE)
# Directories
list.files(dataDir)
?Sys.glob
?list.file
?list.files
list.files(dataDir, recursive = TRUE)
list.files(dataDir, recursive = TRUE, pattern = "\\.(?:jpg|jpeg|gif|png)$")
list.files(dataDir, recursive = TRUE, pattern = "\\.kml$")
list.files(dataDir, recursive = TRUE, pattern = "kml$")
list.files(dataDir, recursive = TRUE, pattern = "kml")
list.files(dataDir, recursive = TRUE, pattern = ".kml")
list.files(dataDir, recursive = TRUE, pattern = "\\.zip$")
list.files(dataDir, recursive = TRUE, pattern = "\\.geojson$")
list.files(dataDir, recursive = TRUE, pattern = "\\.geo.json$")
list.files(dataDir, recursive = TRUE, pattern = "\\.json$")
list.files(dataDir, recursive = TRUE, pattern = ".kml")
list.files(dataDir, recursive = TRUE, pattern = "\\.kml$")
## Limit to certain subdirectories
list.files(dataDir)
## Limit to certain subdirectories
list.files(dataDir, recursive = TRUE)
## Limit to certain subdirectories
searchPaths <- Sys.glob(file.path(dataDir))
searchPaths
searchPaths <- c(
file.path(dataDir, "geo"),
file.path(dataDir, "dates")
)
list.files(searchPaths, recursive = TRUE)
?list.file
?list.files
searchPaths <- Sys.glob(
file.path(dataDir, "images", "C?")
)
?dir
list.files(dataDir, recursive = TRUE, pattern = "^[a]")
list.files(dataDir, recursive = TRUE, pattern = "^[d]")
searchPaths <- c(
file.path(dataDir, "geo"),
file.path(dataDir, "dates")
)
list.files(searchPaths, recursive = TRUE)
list.files(searchPaths, recursive = TRUE, full.names = TRUE)
searchPaths <- Sys.glob(
file.path(dataDir, "images", "C?")
)
file.path(dataDir, "images", "C?")
searchPaths <- Sys.glob(
file.path(dataDir, "images", "^[C]?")
)
searchPaths <- Sys.glob(
file.path(dataDir, "images", "[C]?")
)
searchPaths <- Sys.glob(
file.path(dataDir, "images", "[C]*")
)
searchPaths
list.files(searchPaths, recursive = TRUE, full.names = TRUE)
kmls <- list.files(dataDir, recursive = TRUE, pattern = ".kml")
kmls <- list.files(dataDir, recursive = TRUE, pattern = ".kml")
for (shape in kmls) {
print(shape)
}
v1
