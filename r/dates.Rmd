---
title: "Dates with Lubridate"
output:
  html_document:
    df_print: paged
    toc: yes
editor_options: 
  chunk_output_type: console
---

<style type = "text/css">h1.title { font-size: 32px;} h1 { font-size: 24px;} h2 { font-size: 20px; } h3 { font-size: 16px; }</style>

```{r include = FALSE}
## Setting global chunk options
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE)
```

# Workspace and Other Setup {.tabset .tabset-fade}
## Packages & Settings
```{r results = "hide"}
library(wso)
wso::util.packs(packs = c("tidyverse", "readxl"))
wso::util.settings()
```

## Directories and Files
```{r}
if (.Platform$OS.type == "windows") {
  stop("Please define your directory for Windows, then delete this line.")
  # baseDir <- "G:\Team Drives\WSO USA - Projects\000 - Project"
} else {
  baseDir <- "~/Desktop/GitHub/code-book/r"
}

dataDir <- file.path(baseDir, "_data", "dates")
```

# Dates
## Defining {.tabset .tabset-fade}
### Strings
```{r error = TRUE}
as_date("2011-06-04")
as_date("June.4.11", format = "%B.%d.%y", tz = "") 
as_date("2011-06-04") %>% str()

# This is the most flexible because you can give it multiple formats
as_date(parse_date_time("2011-06-04", "%Y-%m-%d"))
as_date(parse_date_time(c("2011-06-04", "June.4.11"), c("%Y-%m-%d", "%B.%d.%y")))

# Shortcuts
ymd("2011-06-04")
mdy("06042011")
dmy("04/06/2011")
ymd("2011-06-04") %>% str()

# Not Lubridate, but still from tidyverse (readr)
parse_date("2011-06-04") 
parse_date("June.4.11", format = "%B.%d.%y") 
parse_date("2011-06-04") %>% str()

# Compare to Base R
# Normal date
as.Date("2011-06-04")
as.Date("June.4.11", format = "%B.%d.%y") 
as.Date("2011-06-04") %>% str()

# Invalid day
as.Date("2011-02-29")
as_date("2011-02-29")
```

### Components
```{r}
# Standard (i.e. uses integers)
make_date("2011", "06", "02")
make_date(2011, 6, 2)
make_date("2011", "06", "02") %>% str()

# Need to parse from string
make_date(2011, match("Jun", month.abb), 4)
make_date(2011, match("June", month.name), 4)

# Compare to Base R
as.Date(paste("2011", "06", "04", sep = "-"))
as.Date(paste(2011, 6, 4, sep = "-"))
as.Date(paste("2011", "06", "04", sep = "-")) %>% str()

as.Date(paste(2011, match("Jun", month.abb), 4, sep = "-"))
as.Date(paste(2011, match("June", month.name), 4, sep = "-"))
```

### Utilities
```{r}
## Get today's date
today()

# Compare to Base R
Sys.Date()
```

## Importing {.tabset .tabset-fade}
### CSV
**Basic**
```{r}
# grade	 class	 date
# A	     2	     10/7/17
# A 	 1	     2/11/15
# D	     1	     11/3/17

simpleDatesCSV <- read_csv(file.path(dataDir, "dates-simple.csv"), 
  col_types = cols(
    grade = col_character(),
    class = col_number(),
    date = col_date(format = "")
  )
)

simpleDatesCSV[1:3,]
```

**Alternate Format**
```{r}
# grade	 class	 date
# A	     2	     June.4.11
# A	     1	     June.4.12
# D	     1	     June.4.13

altDatesCSV <- read_csv(file.path(dataDir, "dates-alt.csv"), 
  col_types = cols(
    grade = col_character(),
    class = col_number(),
    date = col_date(format = "%B.%d.%y")
  )
)

altDatesCSV[1:3,]
altDatesCSV[[1,3]]
```

**Numeric**
```{r}
# grade	 class	 date
# A	     2	     40698
# A	     1	     40699
# D	     1	     40700

numericDatesCSV <- read_csv(file.path(dataDir, "dates-numeric.csv"), 
    col_types = cols(
      grade = col_character(),
      class = col_number(),
      date = col_character()
    )
  ) %>%
    mutate(
      ## Using another library here because it's way easier. But any way you shake it, there may
      ## be some seconds being messed with because of conversions
      date = as_date(openxlsx::convertToDateTime(date))
    )

numericDatesCSV[1:3,]
numericDatesCSV[[1,3]]
```

**Mixed Formats (No Numerics)**
```{r warning = TRUE}
# grade	  class	  date
# A	      2	      10 1 16
# A	      1	      9.17.2016
# D	      1	      6/6/17

formats <- c("%m %d %y", "%b.%d.%Y", "%m/%d/%y")

mixedDatesCSV <- read_csv(file.path(dataDir, "dates-mixed.csv"), 
    col_types = cols(
      grade = col_character(),
      class = col_double(),
      date = col_character()
    )
  ) %>%
  mutate(
    date = as_date(parse_date_time(date, orders = formats))
  )

mixedDatesCSV[1:3,]
mixedDatesCSV[[1,3]]
```

**Mixed Formats (With Numerics)**
```{r warning = TRUE}
# grade	  class	  date
# A	      2	      43015
# A	      1	      9.17.2016
# D	      1	      6/6/17

formats <- c("%b.%d.%Y", "%m/%d/%y")

mixedNumericDatesCSV <- read_csv(file.path(dataDir, "dates-mixed-numeric.csv"), 
    col_types = cols(
      grade = col_character(),
      class = col_double(),
      date = col_character()
    )
  ) %>%
  mutate(
    # This will cause some warnings, so make sure everything parses correctly
    date = if_else(
      !is.na(openxlsx::convertToDate(date)),
      openxlsx::convertToDate(date),
      as_date(parse_date_time(date, orders = formats))
    )
  )

mixedNumericDatesCSV[1:3,]
mixedNumericDatesCSV[[1,3]]
```

**Base R**
```{r}
# grade	 class	 date
# A	     2	     10/7/17
# A 	 1	     2/11/15
# D	     1	     11/3/17

## Fails initial import
simpleDatesCSVR <- read.csv(file.path(dataDir, "dates-simple.csv"), 
  header = TRUE,
  colClasses = c(
    "character", # grade
    "numeric",   # class
    "Date"       # date
  )
)

## Try again, but bring in the date column as a character...
simpleDatesCSVR <- read.csv(file.path(dataDir, "dates-simple.csv"), 
  header = TRUE,
  colClasses = c(
    "character", # grade
    "numeric",   # class
    "character"  # date
  )
)

simpleDatesCSVR <- simpleDatesCSVR %>%
  mutate(
    date = as.Date(date, "%m/%d/%y")
  )

simpleDatesCSVR[1:3,]
```

### Excel
**Basic**
```{r}
# grade	 class	 date
# A	     2	     10/7/17
# A 	 1	     2/11/15
# D	     1	     11/3/17

simpleDatesXL <- read_excel(file.path(dataDir, "dates-simple.xlsx"), 
    col_types = c(
      "text",     # grade
      "numeric",  # class
      "date"      # date
    )
  ) %>%
  # Comes out as date time, so need to convert to simple date
  mutate(
    date = as_date(date)
  )

simpleDatesXL[1:3,]
simpleDatesXL[[1,3]]
```

**Alternate Format**
```{r}
# grade	 class	 date
# A	     2	     June.4.11
# A	     1	     June.4.12
# D	     1	     June.4.13

altDatesXL <- read_excel(file.path(dataDir, "dates-alt.xlsx"), 
    col_types = c(
      "text",     # grade
      "numeric",  # class
      "text"      # date
    )
  ) %>%
  mutate(
    date = as_date(date, format = "%B.%d.%y", tz = "") 
  )

altDatesXL[1:3,]
altDatesXL[[1,3]]
```

**Numeric**
```{r}
# grade	 class	 date
# A	     2	     40698
# A	     1	     40699
# D	     1	     40700

numericDatesXL <- read_excel(file.path(dataDir, "dates-numeric.xlsx"), 
    col_types = c(
      "text",     # grade
      "numeric",  # class
      "text"      # date
    )
  ) %>%
    mutate(
      ## Using another library here because it's way easier. But any way you shake it, there may
      ## be some seconds being messed with because of conversions
      date = as_date(openxlsx::convertToDateTime(date))
    )

numericDatesXL[1:3,]
numericDatesXL[[1,3]]
```

**Mixed Formats (No Numerics)**
```{r warning = TRUE}
# grade	  class	  date
# A	      2	      10 1 16
# A	      1	      9.17.2016
# D	      1	      6/6/17

formats <- c("%m %d %y", "%b.%d.%Y", "%m/%d/%y")

mixedDatesXL <- read_excel(file.path(dataDir, "dates-mixed.xlsx"), 
    col_types = c(
      "text",     # grade
      "numeric",  # class
      "text"      # date
    )
  ) %>%
  mutate(
    date = as_date(parse_date_time(date, orders = formats))
  )

mixedDatesXL[1:3,]
mixedDatesXL[[1,3]]
```

**Mixed Formats (With Numerics)**
```{r warning = TRUE}
# grade	  class	  date
# A	      2	      43015
# A	      1	      9.17.2016
# D	      1	      6/6/17

formats <- c("%b.%d.%Y", "%m/%d/%y")

mixedNumericDatesXL <- read_excel(file.path(dataDir, "dates-mixed-numeric.xlsx"), 
    col_types = c(
      "text",     # grade
      "numeric",  # class
      "text"      # date
    )
  ) %>%
  mutate(
    # This will cause some warnings, so make sure everything parses correctly
    date = if_else(
      !is.na(openxlsx::convertToDate(date)),
      openxlsx::convertToDate(date),
      as_date(parse_date_time(date, orders = formats))
    )
  )

mixedNumericDatesXL[1:3,]
mixedNumericDatesXL[[1,3]]
```


## Calculating {.tabset .tabset-fade}
### Rounding

```{r}
normalDate <- as_date("2014-02-28")

# Choices for explicit rounding 
# second, minute, hour, day, week, month, bimonth, quarter, season, halfyear, year

# Round down
floor_date(normalDate, unit = "month")
floor_date(normalDate, unit = "year")

# Careful, because the default rounding unit is "seconds", 
# which converts date to POSIXct, with UTC timezone
floor_date(normalDate) %>% str()
floor_date(normalDate) %>% tz()

floor_date(normalDate, unit = "month") %>% str()
floor_date(normalDate, unit = "month") %>% tz()

## Round up
ceiling_date(normalDate, unit = "month")
ceiling_date(normalDate, unit = "year") 

## General round
round_date(normalDate, unit = "month")
round_date(normalDate, unit = "year")

## To bigger units
round_date(normalDate, unit = "10 years")

## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: secs, mins, hours, days, months, years

## General round and round down
round(as.POSIXct(normalDate), "months")
trunc(as.POSIXct(normalDate), "months")
```

### Adjusting in calendar time
```{r}
normalDate <- as_date("2014-02-28")
leapYear <- as_date("2016-02-28")
leapDay <- as_date("2016-02-29")
enterDST <- as_date("2019-03-09")
exitDST <- as_date("2019-11-02")

normalDate + days(1) # We are adding "periods", which represent human time
normalDate + weeks(1)
normalDate + months(1)
normalDate + years(1)

leapYear + days(1) # Notice periods are smart enough to handle Feb 29
leapYear + weeks(1)
leapYear + months(1)
leapYear + years(1)

leapDay + days(1) 
leapDay + weeks(1)
leapDay + months(1)
leapDay + years(1) # But not so smart to nicely handle this situation. 
leapDay + dyears(1) # There is no February 29 a year later, so we need to use dyears
leapDay + days(364)
leapDay + days(365)
leapDay + days(366)

enterDST + days(1)
enterDST + weeks(1)
enterDST + months(1)
enterDST + years(1)

exitDST + days(1)
exitDST + weeks(1)
exitDST + months(1)
exitDST + years(1)

## Gives us a date back
str(normalDate + days(1))
```

### Adjusting in physical time
```{r}
normalDate + years(1) # This is with a period, as before.
normalDate + dyears(1) # This is with a "duration", which is always stored in second. Here there is no difference from the answer above, because dyears represent the average 

leapYear + years(1) # Period.
leapYear + dyears(1) # Duration. This only gets us part of the way there because we added an exact duration of the average year, which is less than the 366 days in this leap year

leapDay + years(1) # Period. Doesn't work here.
leapDay + dyears(1) # This does, but we got lucky because the math works out (see previous example).

```

### Classes for storing time difference
```{r}
normalDate_later <- as_date("2014-03-02") # from 2014-02-28
leapYear_later <- as_date("2016-03-02") # from 2016-02-28
enterDST_later <- as_date("2019-03-11") # from 2019-03-09
exitDST_later <- as_date("2019-11-04") # from 2019-11-02

# (1) Difftime -> Base R class in undetermined units (below gives us days)
# The units can change depending on the dates/times used
(normalDate_later - normalDate) %>% str()
difftime(normalDate_later, normalDate) %>% str() # Longhand version, but notice that end date comes first, which is strange to me

# (2) Duration -> Lubridate class in seconds
# Basically the same as difftime, but never changes from seconds.
as.duration(normalDate_later - normalDate) %>% str()

# (3) Interval -> Lubridate class that stores two dates in one
# Can use several utitliy functions specific to this class for determining relationships
# between dates (e.g. %within%)
interval(normalDate, normalDate_later) %>% str()
```

### Calculating time difference
```{r}
## Difftime ------------------------------------------------------------------------------

# Shorthand
(normalDate_later - normalDate) %>% time_length("second")
(normalDate_later - normalDate) %>% time_length("minute")
(normalDate_later - normalDate) %>% time_length("hour")
(normalDate_later - normalDate) %>% time_length("day")
# WARNING: Do not use units higher than week because they have ambiguous lengths.
# For example, one month may be 28, 29, 30, or 31 days long.

(leapYear_later - leapYear) %>% time_length("day") # Note this is 3 days because of leap year
(enterDST_later - enterDST) %>% time_length("day")
(exitDST_later - exitDST) %>% time_length("day")

# Longhand
difftime(normalDate, normalDate_later) %>% str()

## Durations ------------------------------------------------------------------------------
as.duration(normalDate_later - normalDate) %>% time_length("second")
as.duration(normalDate_later - normalDate) %>% time_length("minute")
as.duration(normalDate_later - normalDate) %>% time_length("hour")
as.duration(normalDate_later - normalDate) %>% time_length("day")
# WARNING: Do not use units higher than week because they have ambiguous lengths.
# For example, one month may be 28, 29, 30, or 31 days long.

as.duration(leapYear_later - leapYear) %>% time_length("day") # Note this is 3 days because of leap year
as.duration(enterDST_later - enterDST) %>% time_length("day")
as.duration(exitDST_later - exitDST) %>% time_length("day")

## Intervals ------------------------------------------------------------------------------
# Note the order is flipped for intervals, with starting date first
interval(normalDate, normalDate_later) %>% time_length("second")
interval(normalDate, normalDate_later) %>% time_length("minute")
interval(normalDate, normalDate_later) %>% time_length("hour")
interval(normalDate, normalDate_later) %>% time_length("day")
# WARNING: Units higher than week give "accurate" results for calendar time, but do not reflect
# correct physical time difference. See examples below.

interval(leapYear, leapYear_later) %>% time_length("day") # Note this is 3 days because of leap year
interval(enterDST, enterDST_later) %>% time_length("day")
interval(exitDST, exitDST_later) %>% time_length("day")

## Other option with Base R ---------------------------------------------------------------
# Choices: secs, mins, hours, days
normalDate_later - normalDate %>% as.numeric("secs") 
normalDate_later - normalDate %>% as.numeric("mins")
normalDate_later - normalDate %>% as.numeric("hours")
normalDate_later - normalDate %>% as.numeric("days")

leapYear_later - leapYear %>% as.numeric("days") # Note this is 3 days because of leap year
enterDST_later - enterDST %>% as.numeric("days")
exitDST_later - exitDST %>% as.numeric("days")

## TAKEAWAY: All methods are fine for calculating physical time differences in units less than a week. Do not use units greater than a week if the goal is precision.

## Units higher than week -------------------------------------------------------------------
# There may be times when you need to use units higher than a week. For example, you might wonder
# how old a meter is in months or years. In these cases, just realize that it doesn't mean much to say how 
# old something is in those units, because they change depending on the year.

# An example to make the point

normalFebStart <- as_date("2014-02-01")
normalFebEnd <- as_date("2014-03-01")
leapFebStart <- as_date("2016-02-01")
leapFebEnd <- as_date("2016-03-01")

(normalFebEnd - normalFebStart) %>% time_length("month")
(leapFebEnd - leapFebStart) %>% time_length("month")
as.duration(normalFebEnd - normalFebStart) %>% time_length("month")
as.duration(leapFebEnd - leapFebStart) %>% time_length("month")
interval(normalFebStart, normalFebEnd) %>% time_length("month")
interval(leapFebStart, leapFebEnd) %>% time_length("month") # Notice this is "correct", but not necessarily accurate. We know that this month is 29 days, but the previous month was 28 days. Why is the answer the same? A human would be happy, but a robot would be mad.
```

### Extracting Components
```{r}
normalDate <- as_date("2014-02-28")

mday(normalDate)
wday(normalDate)
wday(normalDate, label = TRUE)
wday(normalDate, label = TRUE, abbr = FALSE)
month(normalDate)
month(normalDate, label = TRUE)
month(normalDate, label = TRUE, abbr = FALSE)
year(normalDate)
```

### Common Tasks
**Buffer audit period**
```{r}
auditStart <- as_date("2016-05-01") # Notice this is a leap year
auditEnd <- as_date("2017-04-30")

## WARNING: This works here because we are only working with dates, 
## but it will cause headaches when time is involved
auditStart - months(2)
auditEnd + months(2) 

## CORRECT
auditStart %m-% months(2)
auditEnd %m+% months(2) 
```

**Create a sequence of dates**
```{r}
testStart <- as_date("2016-02-01") # Notice this is a leap year
testEnd <- as_date("2017-04-30")
```

**Plot event in month, regardles of year**
```{r}

```

# Datetimes
## Defining {.tabset .tabset-fade}
### Strings
```{r}
as_datetime("2011-06-04 11:30:00")
as_datetime("2011-06-04 11:30:00", tz = "US/Pacific")
as_datetime("June/4/11 11:30 PM", format = "%B/%d/%y %I:%M %p")
as_datetime("2011-06-04 11:30:00") %>% str()
as_datetime("June/4/11 11:30", format = "%B/%d/%y %I:%M") %>% str() # This is POSIXlt... not sure why right now
as_datetime("2011-06-04 11:30:00") %>% tz() # Defaults to POSIXct in UTC

# Shortcuts
ymd_hms("2010-08-03 12:00:00")
mdy_hms("06042011 12:00:00", tz = "US/Pacific")
dmy_hm("04/06/2011 12:00")
dmy_h("04/06/2011 12")
ymd_hms("2010-08-03 12:00:00") %>% str()
ymd_hms("2010-08-03 12:00:00") %>% tz()

parse_date_time("2011-06-04 11:30:00", "%Y-%m-%d $H:%M:%S") 
parse_date_time(c("2011-06-04 11:30:00", "June/4/11 11:30 PM"), orders = c("%Y-%m-%d $H:%M:%S", "%B/%d/%y %I:%M %p"), tz = "US/Pacific")
parse_date_time("2011-06-04 11:30:00", "%Y-%m-%d $H:%M:%S") %>% str()
parse_date_time("2011-06-04 11:30:00", "%Y-%m-%d $H:%M:%S") %>% tz()
parse_date_time("2011-06-04 11:30:00", "%Y-%m-%d $H:%M:%S", tz = "US/Pacific") %>% tz()

# Not Lubridate, but still from tidyverse (readr)
parse_datetime("2011-06-04 11:30:00") 
parse_datetime("2011-06-04 11:30:00", locale = locale(tz = "US/Pacific")) 
parse_datetime("June/4/11 11:30 PM", format = "%B/%d/%y %I:%M %p") 
parse_datetime("2011-06-04 11:30:00") %>% str() # Defaults to POSIXct
parse_datetime("2011-06-04 11:30:00") %>% tz() # Defaults to UTC

# Compare to Base R
as.POSIXct("2011-06-04 11:30:00") # Notice PDT (my computer's time zone)
as.POSIXct("2011-06-04 11:30:00", tz = "UTC")
as.POSIXct("2011-06-04 11:30:00", tz = "US/Pacific") 
as.POSIXct("June/4/11 11:30 PM", format = "%B/%d/%y %I:%M %p") 
as.POSIXct("June/4/11 11:30 PM", tryFormats = c("%B/%d/%y %I:%M %p", "%B/%d/%y %I:%M %p"))
as.POSIXct("2011-06-04 11:30:00") %>% str()
as.POSIXct("2011-06-04 11:30:00") %>% tz() # Does not have a timezone set

as.POSIXlt("2011-06-04 11:30:00") # Notice PDT (my computer's time zone)
as.POSIXlt("2011-06-04 11:30:00", tz = "UTC")
as.POSIXlt("2011-06-04 11:30:00", tz = "US/Pacific")
as.POSIXlt("June/4/11 11:30 PM", format = "%B/%d/%y %I:%M %p") 
as.POSIXlt("June/4/11 11:30 PM", tryFormats = c("%B/%d/%y %I:%M %p", "%B/%d/%y %I:%M %p"))
as.POSIXlt("2011-06-04 11:30:00") %>% str()
as.POSIXlt("2011-06-04 11:30:00") %>% tz() # Does not have a timezone set

strptime("2011-06-04 11:30:00", format = "%Y-%m-%d %I:%M:%S") # Notice PDT (my computer's time zone)
strptime("2011-06-04 11:30:00", format = "%Y-%m-%d %I:%M:%S", tz = "UTC")
strptime("2011-06-04 11:30:00", format = "%Y-%m-%d %I:%M:%S", tz = "US/Pacific")
strptime("June/4/11 11:30 PM", format = "%B/%d/%y %I:%M %p")
strptime("2011-06-04 11:30:00", format = "%Y-%m-%d %I:%M:%S") %>% str() # Creates POSIXlt
strptime("2011-06-04 11:30:00", format = "%Y-%m-%d %I:%M:%S") %>% attr("tzone") # But this is null
strptime("2011-06-04 11:30:00", format = "%Y-%m-%d %I:%M:%S") %>% tz() # UTC
## So we get a print of PDT, a NULL time zone attribute, and lubridate is telling us UTC...

## The tzone attribute controls how the date/time is printed, not what absolute time it refers to. If it is not set (as above) it defaults to your systems time zone (I'm on PDT right now). In this case, Lubridate knows the absolute time is in UTC, we don't have an attribute set, so it prints in PDT. 

## Takeaway... specify the time zone to avoid ambiguity.

# Invalid datetime
as_datetime("2011-02-29 11:30:00", format = "%Y-%m-%d %I:%M:%S")
as.POSIXct("2011-02-29 11:30:00", format = "%Y-%m-%d %I:%M:%S")
as.POSIXlt("2011-02-29 11:30:00", format = "%Y-%m-%d %I:%M:%S")
strptime("2011-02-29 11:30:00", format = "%Y-%m-%d %I:%M:%S")
```

### Components
```{r}
# Standard (i.e. uses integers)
make_datetime(2011, 6, 2, 1, 1, 1)
make_datetime(2011, 6, 2, 00, 00, 00)
make_datetime(2011, 6, 2, 00, 00, 00, tz = "UTC")
make_datetime(2011, 6, 2, 00, 00, 00, tz = "US/Pacific")
make_datetime(2011, 6, 2, 1, 1, 1) %>% str()

# Need to parse from string
make_datetime(2011, match("Jun", month.abb), 4, 12, 30, 0)
make_datetime(2011, match("June", month.name), 4, 12, 30, 00)
make_datetime(2011, match("Jun", month.abb), 4, 12, 30, 0) %>% str()

# Compare to Base R
as.POSIXct(paste(paste("2011", "06", "04", sep = "-"), paste("12", "30", "00", sep = ":")))
as.POSIXct(paste(paste(2011, 6, 4, sep = "-"), paste(12, 30, 00, sep = ":")))
as.POSIXct(paste(paste("2011", "06", "04", sep = "-"), paste("12", "30", "00", sep = ":"))) %>% str()
```

### Utilities
```{r}
## Get today's date
now() # Local time zone
now("UTC")

# Compare to Base R
Sys.time()
```

## Importing {.tabset .tabset-fade}
### CSV
**Basic**
```{r}
# category	 temp	 datetime
# cool	     55	     2011-06-04 09:30:00
# warm 	     60	     2011-06-05 09:30:01
# warm	     65	     2011-06-06 13:30:02

simpleDatetimesCSV <- read_csv(file.path(dataDir, "datetimes-simple.csv"), 
    col_types = cols(
      category = col_character(),
      temp = col_number(),
      datetime = col_character()
    )
  ) %>%
  # Set the time zone of datetimes
  mutate(
    datetime = parse_datetime(datetime, locale = locale(tz = "US/Pacific"))
  )

simpleDatetimesCSV[1:3,]
simpleDatetimesCSV[[1,3]] %>% tz()
```

**Alternate Format**
```{r}
# category	 temp	  datetime
# cool	     55	      Jun.4.2011 9:30
# warm 	     60	      Jun.5.2011 10:00
# warm	     65	      Jun.6.2011 13:50

altDatetimesCSV <- read_csv(file.path(dataDir, "datetimes-alt.csv"), 
    col_types = cols(
      category = col_character(),
      temp = col_number(),
      datetime = col_character()
    )
  ) %>%
  # Set the time zone of datestimes
  mutate(
    datetime = parse_datetime(datetime, format = "%b.%d.%Y %H:%M", locale = locale(tz = "US/Pacific"))
  )

altDatetimesCSV[1:3,]
altDatetimesCSV[[1,3]] %>% tz()
```

**Numeric**
```{r}
# category	 temp	  datetime
# cool	     55	      40698.401
# warm 	     60	      40699.442
# warm	     65	      40700.483

numericDatetimesCSV <- read_csv(file.path(dataDir, "datetimes-numeric.csv"), 
    col_types = cols(
      category = col_character(),
      temp = col_number(),
      datetime = col_character()
    )
  ) %>%
  mutate(
    ## Using another library here because it's way easier. But any way you shake it, there may
    ## be some seconds being messed with because of conversions
    datetime = force_tz(openxlsx::convertToDateTime(datetime), tzone = "US/Pacific")
  )

numericDatetimesCSV[1:3,]
numericDatetimesCSV[[1,3]] %>% tz()
```

**Mixed Formats (No numerics)**
```{r warning = TRUE}
# category	 temp	 datetime
# cool	     55	     Jun.4.2011 10:30
# warm 	     60	     6/5/11 11:00 AM
# warm	     65	     Jun.6.2011 10:30

formats <- c("%b.%d.%Y %H:%M", "%m/%d/%y %I:%M %p")

mixedDatetimesCSV <- read_csv(file.path(dataDir, "datetimes-mixed.csv"), 
    col_types = cols(
      category = col_character(),
      temp = col_number(),
      datetime = col_character()
    )
  ) %>%
  mutate(
    datetime = parse_date_time(datetime, orders = formats, tz = "US/Pacific")
  )

mixedDatetimesCSV[1:3,]
mixedDatetimesCSV[[1,3]] %>% tz()
```

**Mixed Formats (With numerics)**
```{r warning = TRUE}
# category	 temp	 datetime
# cool	     55	     40699.42
# warm 	     60	     6/5/11 10:30
# warm	     65	     Jun.6.2011 10:30

formats <- c("%b.%d.%Y %H:%M", "%m/%d/%y %H:%M")

mixedNumericDatetimesCSV <- read_csv(file.path(dataDir, "datetimes-mixed-numeric.csv"), 
    col_types = cols(
      category = col_character(),
      temp = col_number(),
      datetime = col_character()
    )
  ) %>%
  mutate(
    # This will cause some warnings, so make sure everything parses correctly
    datetime = if_else(
      !is.na(force_tz(openxlsx::convertToDateTime(datetime), tzone = "US/Pacific")),
      force_tz(openxlsx::convertToDateTime(datetime), tzone = "US/Pacific"),
      parse_date_time(datetime, orders = formats, tz = "US/Pacific")
    )
  )

mixedNumericDatetimesCSV[1:3,]
mixedNumericDatetimesCSV[[1,3]] %>% tz()
```

**Base R**
```{r}
# category	 temp	 datetime
# cool	     55	    2011-06-04 09:30:00
# warm 	      60	     2011-06-05 09:30:01
# warm	     65	     2011-06-06 13:30:02

simpleDatetimesCSVR <- read.csv(file.path(dataDir, "datetimes-simple.csv"), 
  header = TRUE,
  colClasses = c(
    "character", 
    "numeric", 
    "POSIXct"
  )
)

simpleDatetimesCSVR[1:3,]
simpleDatetimesCSVR[[1,3]] %>% tz() # No time zone

simpleDatetimesCSVR <- simpleDatetimesCSVR %>%
  mutate(
    datetime = force_tz(datetime, tzone = "US/Pacific")
  )

simpleDatetimesCSVR[1:3,]
simpleDatetimesCSVR[[1,3]] %>% tz()
```

### Excel
**Basic**
```{r}
# category	 temp	 datetime
# cool	     55	     6/4/11 9:30 AM
# warm 	    60	     6/4/11 10:30 AM
# warm	     65	     6/4/11 11:30 AM

simpleDatetimesXL <- read_excel(file.path(dataDir, "datetimes-simple.xlsx"), 
    col_types = c(
      "text",     # category
      "numeric",  # temp
      "text"      # datetime
    )
  ) %>%
  mutate(
    datetime = parse_datetime(datetime, locale = locale(tz = "US/Pacific"))
  )

simpleDatetimesXL[1:3,]
simpleDatetimesXL[[1,3]] %>% tz()
```

**Alternate Format**
```{r}
# category	 temp	 datetime
# cool	     55	     Jun.4.2011 9:30
# warm 	     60	     Jun.5.2011 10:00
# warm	     65	     Jun.6.2011 13:50

altDatetimesXL <- read_excel(file.path(dataDir, "datetimes-alt.xlsx"), 
    col_types = c(
      "text",     # category
      "numeric",  # temp
      "text"      # datetime
    )
  ) %>%  
  # Set the time zone of datestimes
  mutate(
    datetime = parse_datetime(datetime, format = "%b.%d.%Y %H:%M", locale = locale(tz = "US/Pacific"))
  )

altDatetimesXL[1:3,]
altDatetimesXL[[1,3]] %>% tz()
```

**Numeric**
```{r}
# category	 temp	  datetime
# cool	     55	      40698.401
# warm 	     60	      40699.442
# warm	     65	      40700.483

numericDatetimesXL <- read_excel(file.path(dataDir, "datetimes-numeric.xlsx"), 
    col_types = c(
      "text",     # category
      "numeric",  # temp
      "text"      # datetime
    )
  ) %>%
  mutate(
    ## Using another library here because it's way easier. But any way you shake it, there may
    ## be some seconds being messed with because of conversions
    datetime = force_tz(openxlsx::convertToDateTime(datetime), tzone = "US/Pacific")
  )

numericDatetimesXL[1:3,]
numericDatetimesXL[[1,3]] %>% tz()
```

**Mixed Formats (No numerics)**
```{r warning = TRUE}
# category	 temp	 datetime
# cool	     55	     Jun.4.2011 10:30
# warm 	     60	     6/5/11 11:00 AM
# warm	     65	     Jun.6.2011 10:30

formats <- c("%b.%d.%Y %H:%M", "%m/%d/%y %I:%M %p")

mixedDatetimesXL <- read_excel(file.path(dataDir, "datetimes-mixed.xlsx"), 
    col_types = c(
      "text",     # category
      "numeric",  # temp
      "text"      # datetime
    )
  ) %>%
  mutate(
    datetime = parse_date_time(datetime, orders = formats, tz = "US/Pacific")
  )

mixedDatetimesXL[1:3,]
mixedDatetimesXL[[1,3]] %>% tz()
```

**Mixed Formats (With numerics)**
```{r warning = TRUE}
# category	 temp	 datetime
# cool	     55	     40699.42
# warm 	     60	     6/5/11 10:30
# warm	     65	     Jun.6.2011 10:30

formats <- c("%b.%d.%Y %H:%M", "%m/%d/%y %H:%M")

mixedNumericDatetimesXL <- read_excel(file.path(dataDir, "datetimes-mixed-numeric.xlsx"), 
    col_types = c(
      "text",     # category
      "numeric",  # temp
      "text"      # datetime
    )
  ) %>%
  mutate(
    # This will cause some warnings, so make sure everything parses correctly
    datetime = if_else(
      !is.na(force_tz(openxlsx::convertToDateTime(datetime), tzone = "US/Pacific")),
      force_tz(openxlsx::convertToDateTime(datetime), tzone = "US/Pacific"),
      parse_date_time(datetime, orders = formats, tz = "US/Pacific")
    )
  )

mixedNumericDatetimesXL[1:3,]
mixedNumericDatetimesXL[[1,3]] %>% tz()
```

## Calculating {.tabset .tabset-fade}
### Rounding

```{r}
normalDateTime <- as_datetime("2014-02-28 20:30:00")
normalDateTimePDT <- as_datetime("2014-02-28 20:30:00", tz = "US/Pacific")

# Choices for explicit rounding 
# second, minute, hour, day, week, month, bimonth, quarter, season, halfyear, year

# Round down
floor_date(normalDateTime, unit = "hour")
floor_date(normalDateTime, unit = "year")

## Round up
ceiling_date(normalDateTime, unit = "hour")
ceiling_date(normalDateTime, unit = "year") 

## General round
round_date(normalDateTime, unit = "hour")
round_date(normalDateTime, unit = "year")

## To bigger units
round_date(normalDateTime, unit = "10 years")

## Base R
# Choices: secs, mins, hours, days, months, years

## General round and round down
round(normalDateTime, "months")
trunc(normalDateTime, "months")
```

### Adjusting in calendar time
```{r}
normalDateTime <- as_datetime("2014-02-28 11:30:00", tz = "US/Pacific")
leapYearTime <- as_datetime("2016-02-28 11:30:00", tz = "US/Pacific")
leapDayTime <- as_datetime("2016-02-29 11:30:00", tz = "US/Pacific")
enterDSTTime_UTC <- as_datetime("2019-03-10 01:30:00")
exitDSTTime_UTC <- as_datetime("2019-11-03 01:30:00")
enterDSTTime_PDT <- as_datetime("2019-03-10 01:30:00", tz = "US/Pacific")
exitDSTTime_PDT <- as_datetime("2019-11-03 01:30:00", tz = "US/Pacific")

normalDateTime + seconds(1) # We are adding "periods", which represent human time
normalDateTime + minutes(1)
normalDateTime + hours(1)
normalDateTime + days(1)
normalDateTime + months(1)

leapYearTime + seconds(1)
leapYearTime + minutes(1)
leapYearTime + hours(1)
leapYearTime + days(1)
leapYearTime + months(1)

leapDayTime + seconds(1)
leapDayTime + minutes(1)
leapDayTime + hours(1)
leapDayTime + days(1)
leapDayTime + months(1)

enterDSTTime_UTC + seconds(1)
enterDSTTime_UTC + minutes(1)
enterDSTTime_UTC + hours(1)
enterDSTTime_UTC + days(1)
enterDSTTime_UTC + months(1)

exitDSTTime_UTC + seconds(1)
exitDSTTime_UTC + minutes(1)
exitDSTTime_UTC + hours(1)
exitDSTTime_UTC + days(1)
exitDSTTime_UTC + months(1)

enterDSTTime_PDT + seconds(1)
enterDSTTime_PDT + minutes(1)
enterDSTTime_PDT + hours(1)
enterDSTTime_PDT + days(1)
enterDSTTime_PDT + months(1)

exitDSTTime_PDT + seconds(1)
exitDSTTime_PDT + minutes(1)
exitDSTTime_PDT + hours(1)
exitDSTTime_PDT + days(1)
exitDSTTime_PDT + months(1)

## Gives us a datetime back
str(normalDateTime + days(1))

## Test in a tibble with enterDSTTime
testTibble <- tibble(
  beforeDST = c(enterDSTTime_UTC),
  beforeDST_tz = c(enterDSTTime_PDT),
  inDST_hour = beforeDST + hours(1),
  inDST_dhour = beforeDST + dhours(1),
  inDST_tz_hour = beforeDST_tz + hours(1),
  inDST_tz_dhour = beforeDST_tz + dhours(1)
)
testTibble
testTibble %>% wso::style.makeTable()
```

### Adjusting in physical time
```{r}
normalDateTime + years(1) # This is with a period, as before.
normalDateTime + dyears(1) # This is with a "duration", which is always stored in second. Here there is no difference from the answer above, because dyears represent the average 

leapYearTime + years(1) # Period.
leapYearTime + dyears(1) # Duration. This only gets us part of the way there because we added an exact duration of the average year, which is less than the 366 days in this leap year

## TAKEWAY: Use periods for calendar time (e.g. days), and durations for physical time (e.g. ddays)
```

### Classes for storing time difference
```{r}
normalDate_later <- as_date("2014-03-02") # from 2014-02-28
leapYear_later <- as_date("2016-03-02") # from 2016-02-28
enterDST_later <- as_date("2019-03-11") # from 2019-03-09
exitDST_later <- as_date("2019-11-04") # from 2019-11-02

# (1) Difftime -> Base R class in undetermined units (below gives us days)
# The units can change depending on the dates/times used
(normalDate_later - normalDate) %>% str()
difftime(normalDate_later, normalDate) %>% str() # Longhand version, but notice that end date comes first, which is strange to me

# (2) Duration -> Lubridate class in seconds
# Basically the same as difftime, but never changes from seconds.
as.duration(normalDate_later - normalDate) %>% str()

# (3) Interval -> Lubridate class that stores two dates in one
# Can use several utitliy functions specific to this class for determining relationships
# between dates (e.g. %within%)
interval(normalDate, normalDate_later) %>% str()
```

### Calculating time difference
```{r}
## Difftime ------------------------------------------------------------------------------

# Shorthand
(normalDate_later - normalDate) %>% time_length("second")
(normalDate_later - normalDate) %>% time_length("minute")
(normalDate_later - normalDate) %>% time_length("hour")
(normalDate_later - normalDate) %>% time_length("day")
# WARNING: Do not use units higher than week because they have ambiguous lengths.
# For example, one month may be 28, 29, 30, or 31 days long.

(leapYear_later - leapYear) %>% time_length("day") # Note this is 3 days because of leap year
(enterDST_later - enterDST) %>% time_length("day")
(exitDST_later - exitDST) %>% time_length("day")

# Longhand
difftime(normalDate, normalDate_later) %>% str()

## Durations ------------------------------------------------------------------------------
as.duration(normalDate_later - normalDate) %>% time_length("second")
as.duration(normalDate_later - normalDate) %>% time_length("minute")
as.duration(normalDate_later - normalDate) %>% time_length("hour")
as.duration(normalDate_later - normalDate) %>% time_length("day")
# WARNING: Do not use units higher than week because they have ambiguous lengths.
# For example, one month may be 28, 29, 30, or 31 days long.

as.duration(leapYear_later - leapYear) %>% time_length("day") # Note this is 3 days because of leap year
as.duration(enterDST_later - enterDST) %>% time_length("day")
as.duration(exitDST_later - exitDST) %>% time_length("day")

## Intervals ------------------------------------------------------------------------------
# Note the order is flipped for intervals, with starting date first
interval(normalDate, normalDate_later) %>% time_length("second")
interval(normalDate, normalDate_later) %>% time_length("minute")
interval(normalDate, normalDate_later) %>% time_length("hour")
interval(normalDate, normalDate_later) %>% time_length("day")
# WARNING: Units higher than week give "accurate" results for calendar time, but do not reflect
# correct physical time difference. See examples below.

interval(leapYear, leapYear_later) %>% time_length("day") # Note this is 3 days because of leap year
interval(enterDST, enterDST_later) %>% time_length("day")
interval(exitDST, exitDST_later) %>% time_length("day")

## Other option with Base R ---------------------------------------------------------------
# Choices: secs, mins, hours, days
normalDate_later - normalDate %>% as.numeric("secs") 
normalDate_later - normalDate %>% as.numeric("mins")
normalDate_later - normalDate %>% as.numeric("hours")
normalDate_later - normalDate %>% as.numeric("days")

leapYear_later - leapYear %>% as.numeric("days") # Note this is 3 days because of leap year
enterDST_later - enterDST %>% as.numeric("days")
exitDST_later - exitDST %>% as.numeric("days")

## TAKEAWAY: All methods are fine for calculating physical time differences in units less than a week. Do not use units greater than a week if the goal is precision.

## Units higher than week -------------------------------------------------------------------
# There may be times when you need to use units higher than a week. For example, you might wonder
# how old a meter is in months or years. In these cases, just realize that it doesn't mean much to say how 
# old something is in those units, because they change depending on the year.

# An example to make the point

normalFebStart <- as_date("2014-02-01")
normalFebEnd <- as_date("2014-03-01")
leapFebStart <- as_date("2016-02-01")
leapFebEnd <- as_date("2016-03-01")

(normalFebEnd - normalFebStart) %>% time_length("month")
(leapFebEnd - leapFebStart) %>% time_length("month")
as.duration(normalFebEnd - normalFebStart) %>% time_length("month")
as.duration(leapFebEnd - leapFebStart) %>% time_length("month")
interval(normalFebStart, normalFebEnd) %>% time_length("month")
interval(leapFebStart, leapFebEnd) %>% time_length("month") # Notice this is "correct", but not necessarily accurate. We know that this month is 29 days, but the previous month was 28 days. Why is the answer the same? A human would be happy, but a robot would be mad.
```

### Extracting Components
```{r}
normalDate <- as_date("2014-02-28")

mday(normalDate)
wday(normalDate)
wday(normalDate, label = TRUE)
wday(normalDate, label = TRUE, abbr = FALSE)
month(normalDate)
month(normalDate, label = TRUE)
month(normalDate, label = TRUE, abbr = FALSE)
year(normalDate)
```

### Common Tasks
*Sequence of timestamps*
```{r}

```

# Formatting for labels {.tabset .tabset-fade}
## Common
```{r}
# Lubridate
# paste()

# Scales
# date_format()

# Base R
# format()
# strftime()
```

## Advanced Labels
```{r}
# stamp_date()
# stamp_datetime()
```

