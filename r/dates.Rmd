---
title: "Dates with Lubridate"
output:
  html_document:
    df_print: paged
    toc: yes
editor_options: 
  chunk_output_type: console
---

<style type = "text/css">h1.title { font-size: 32px;} h1 { font-size: 24px;} h2 { font-size: 20px; } h3 { font-size: 16px; }</style>

```{r include = FALSE}
## Setting global chunk options
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE)
```

# Workspace and Other Setup {.tabset .tabset-fade}
## Packages & Settings
```{r results = "hide"}
library(wso)
wso::util.packs(packs = c("tidyverse", "readxl"))
wso::util.settings()
```

## Directories and Files
```{r}
if (.Platform$OS.type == "windows") {
  stop("Please define your directory for Windows, then delete this line.")
  # baseDir <- "G:\Team Drives\WSO USA - Projects\000 - Project"
} else {
  baseDir <- "~/Desktop/GitHub/code-book/r"
}

dataDir <- file.path(baseDir, "_data")
```

# Dates
## Defining {.tabset .tabset-fade}
### Strings
```{r error = TRUE}
# Most flexible
as_date("2011-06-04")
as_date("June.4.11", format = "%B.%d.%y", tz = "") 
as_date("2011-06-04") %>% str()

# Shortcuts
ymd("2011-06-04")
mdy("06042011")
dmy("04/06/2011")
ymd("2011-06-04") %>% str()

# Not Lubridate, but still from tidyverse (readr)
parse_date("2011-06-04") 
parse_date("June.4.11", format = "%B.%d.%y") 

# Compare to Base R
# Normal date
as.Date("2011-06-04")
as.Date("June.4.11", format = "%B.%d.%y") 
as.Date("2011-06-04") %>% str()

# Invalid day
as.Date("2011-02-29")
as_date("2011-02-29")
```

### Components
```{r}
# Standard (i.e. uses integers)
make_date("2011", "06", "02")
make_date(2011, 6, 2)
make_date("2011", "06", "02") %>% str()

# Need to parse from string
make_date(2011, match("Jun", month.abb), 4)
make_date(2011, match("June", month.name), 4)

# Compare to Base R
as.Date(paste("2011", "06", "04", sep = "-"))
as.Date(paste(2011, 6, 4, sep = "-"))
as.Date(paste("2011", "06", "04", sep = "-")) %>% str()

as.Date(paste(2011, match("Jun", month.abb), 4, sep = "-"))
as.Date(paste(2011, match("June", month.name), 4, sep = "-"))
```

### Utilities
```{r}
## Get today's date
today()

# Compare to Base R
Sys.Date()
```

## Importing {.tabset .tabset-fade}
### CSV
**Basic**
```{r}
# grade	 class	 date
# A	     2	     10/7/17
# A 	 1	     2/11/15
# D	     1	     11/3/17

simpleDatesCSV <- read_csv(file.path(dataDir, "dates-simple.csv"), 
  col_types = cols(
    grade = col_character(),
    class = col_number(),
    date = col_date(format = "")
  )
)

simpleDatesCSV[1:3,]
```

**Alternate Format**
```{r}
# grade	 class	 date
# A	     2	     June.4.11
# A	     1	     June.4.12
# D	     1	     June.4.13

altDatesCSV <- read_csv(file.path(dataDir, "dates-alt.csv"), 
  col_types = cols(
    grade = col_character(),
    class = col_number(),
    date = col_date(format = "%B.%d.%y")
  )
)

altDatesCSV[1:3,]
```

**Mixed Formats**
```{r warning = TRUE}
# grade	  class	  date
# A	      2	      43015
# A	      1	      9.17.2016
# D	      1	      6/6/17

## Fails initial import
mixedDatesCSV <- read_csv(file.path(dataDir, "dates-mixed.csv"), 
  col_types = cols(
    grade = col_character(),
    class = col_number(),
    date = col_date(format = "")
  )
)

## Try again, but bring in the date column as a character...
mixedDatesCSV <- read_csv(file.path(dataDir, "dates-mixed.csv"), 
  col_types = cols(
    grade = col_character(),
    class = col_double(),
    date = col_character()
  )
)

## ... then try to parse your dates with a case_when syntax. Warning, you will see warnings, so you
## need to spot check the results to make sure the dates were parsed correctly.

mixedDatesCSV <- mixedDatesCSV %>%
  mutate(
    date = case_when(
      !is.na(parse_date(date, "%m.%d.%Y")) ~ parse_date(date, "%m.%d.%Y"),
      !is.na(parse_date(date, "%m/%d/%y")) ~ parse_date(date, "%m/%d/%y"),
      TRUE ~ as_date(as.numeric(date), origin = "1899-12-30")
    )
  )

mixedDatesCSV[1:3,]

```

**Base R**
```{r}
# @TODO read.csv
```

### Excel
**Basic**
```{r}
# grade	 class	 date
# A	     2	     10/7/17
# A 	 1	     2/11/15
# D	     1	     11/3/17

simpleDatesXL <- read_excel(file.path(dataDir, "dates-simple.xlsx"), 
  col_types = c(
    "text",     # grade
    "numeric",  # class
    "date"      # date
  )
)
 
# Comes out as date time, so need to coerce
simpleDatesXL <- simpleDatesXL %>%
  mutate(
    date = as_date(date)
  )

simpleDatesXL[1:3,]
```

**Alternate Format**
```{r}
# grade	 class	 date
# A	     2	     June.4.11
# A	     1	     June.4.12
# D	     1	     June.4.13

altDatesXL <- read_excel(file.path(dataDir, "dates-alt.xlsx"), 
  col_types = c(
    "text",     # grade
    "numeric",  # class
    "date"      # date
  )
)

altDatesXL[1:3,]
```

**Mixed Formats**
```{r warning = TRUE}
# grade	  class	  date
# A	      2	      43015
# A	      1	      9.17.2016
# D	      1	      6/6/17

## Fails initial import
mixedDatesXL <- read_excel(file.path(dataDir, "dates-mixed.xlsx"), 
  col_types = c(
    "text",     # grade
    "numeric",  # class
    "date"      # date
  )
)

## Result
# grade	  class	  date
# A	      2	      2017-10-07
# A	      1	      NA
# D	      1	      2017-06-06

## Try again, but bring in the date column as a character...
mixedDatesXL <- read_excel(file.path(dataDir, "dates-mixed.xlsx"), 
  col_types = c(
    "text",     # grade
    "numeric",  # class
    "text"      # date
  )
)

## ... then try to parse your dates with a case_when syntax. Warning, you will see warnings, so you
## need to spot check the results to make sure the dates were parsed correctly.

mixedDatesXL <- mixedDatesXL %>%
  mutate(
    date = case_when(
      !is.na(parse_date(date, "%m.%d.%Y")) ~ parse_date(date, "%m.%d.%Y"),
      !is.na(parse_date(date, "%m/%d/%y")) ~ parse_date(date, "%m/%d/%y"),
      TRUE ~ as_date(as.numeric(date), origin = "1899-12-30")
    )
  )

mixedDatesXL[1:3,]

```

**Base R**
```{r}
# @TODO read.xlsx
```

## Calculating {.tabset .tabset-fade}
### Rounding

```{r}
normalDate <- as_date("2014-02-28")

## Round down
floor_date(normalDate) 

# Careful, because the default rounding unit is "seconds", 
# which converts date to POSIXct, with UTC timezone
floor_date(normalDate) %>% str()
floor_date(normalDate) %>% tz()

# Choices for explicit rounding 
# second, minute, hour, day, week, month, bimonth, quarter, season, halfyear, year

# Round down
floor_date(normalDate, unit = "month")
floor_date(normalDate, unit = "year")

## Round up
ceiling_date(normalDate, unit = "month")
ceiling_date(normalDate, unit = "year") 

## General round
round_date(normalDate, unit = "month")
round_date(normalDate, unit = "year")

## To bigger units
round_date(normalDate, unit = "10 years")

## Base R
# Only available for POSIXct, so if you must do this
# with your date object in base R, coerce it
# Choices: secs, mins, hours, days, months, years

## General round and round down
round(as.POSIXct(normalDate), "months")
trunc(as.POSIXct(normalDate), "months")
```

### Adjusting in calendar time
```{r}
normalDate <- as_date("2014-02-28")
leapYear <- as_date("2016-02-28")
enterDST <- as_date("2019-03-09")
exitDST <- as_date("2019-11-02")

normalDate + days(1) # We are adding "periods", which represent human time
normalDate + weeks(1)
normalDate + months(1)
normalDate + years(1)

leapYear + days(1) # Notice periods are smart enough to handle Feb 29
leapYear + weeks(1)
leapYear + months(1)
leapYear + years(1)

enterDST + days(1)
enterDST + weeks(1)
enterDST + months(1)
enterDST + years(1)

exitDST + days(1)
exitDST + weeks(1)
exitDST + months(1)
exitDST + years(1)

## Gives us a date back
str(normalDate + days(1))
```

### Adjusting in physical time
```{r}
normalDate + years(1) # This is with a period, as before.
normalDate + dyears(1) # This is with a "duration", which is always stored in second. Here there is no difference from the answer above, because dyears represent the average 

leapYear + years(1) # Period.
leapYear + dyears(1) # Duration. This only gets us part of the way there because we added an exact duration of the average year, which is less than the 366 days in this leap year

## TAKEWAY: Use periods for calendar time (e.g. days), and durations for physical time (e.g. ddays)
```

### Classes for storing time difference
```{r}
normalDate_later <- as_date("2014-03-02") # from 2014-02-28
leapYear_later <- as_date("2016-03-02") # from 2016-02-28
enterDST_later <- as_date("2019-03-11") # from 2019-03-09
exitDST_later <- as_date("2019-11-04") # from 2019-11-02

# (1) Difftime -> Base R class in undetermined units (below gives us days)
# The units can change depending on the dates/times used
(normalDate_later - normalDate) %>% str()
difftime(normalDate_later, normalDate) %>% str() # Longhand version, but notice that end date comes first, which is strange to me

# (2) Duration -> Lubridate class in seconds
# Basically the same as difftime, but never changes from seconds.
as.duration(normalDate_later - normalDate) %>% str()

# (3) Interval -> Lubridate class that stores two dates in one
# Can use several utitliy functions specific to this class for determining relationships
# between dates (e.g. %within%)
interval(normalDate, normalDate_later) %>% str()
```

### Calculating time difference
```{r}
## Difftime ------------------------------------------------------------------------------

# Shorthand
(normalDate_later - normalDate) %>% time_length("second")
(normalDate_later - normalDate) %>% time_length("minute")
(normalDate_later - normalDate) %>% time_length("hour")
(normalDate_later - normalDate) %>% time_length("day")
# WARNING: Do not use units higher than week because they have ambiguous lengths.
# For example, one month may be 28, 29, 30, or 31 days long.

(leapYear_later - leapYear) %>% time_length("day") # Note this is 3 days because of leap year
(enterDST_later - enterDST) %>% time_length("day")
(exitDST_later - exitDST) %>% time_length("day")

# Longhand
difftime(normalDate, normalDate_later) %>% str()

## Durations ------------------------------------------------------------------------------
as.duration(normalDate_later - normalDate) %>% time_length("second")
as.duration(normalDate_later - normalDate) %>% time_length("minute")
as.duration(normalDate_later - normalDate) %>% time_length("hour")
as.duration(normalDate_later - normalDate) %>% time_length("day")
# WARNING: Do not use units higher than week because they have ambiguous lengths.
# For example, one month may be 28, 29, 30, or 31 days long.

as.duration(leapYear_later - leapYear) %>% time_length("day") # Note this is 3 days because of leap year
as.duration(enterDST_later - enterDST) %>% time_length("day")
as.duration(exitDST_later - exitDST) %>% time_length("day")

## Intervals ------------------------------------------------------------------------------
# Note the order is flipped for intervals, with starting date first
interval(normalDate, normalDate_later) %>% time_length("second")
interval(normalDate, normalDate_later) %>% time_length("minute")
interval(normalDate, normalDate_later) %>% time_length("hour")
interval(normalDate, normalDate_later) %>% time_length("day")
# WARNING: Units higher than week give "accurate" results for calendar time, but do not reflect
# correct physical time difference. See examples below.

interval(leapYear, leapYear_later) %>% time_length("day") # Note this is 3 days because of leap year
interval(enterDST, enterDST_later) %>% time_length("day")
interval(exitDST, exitDST_later) %>% time_length("day")

## Other option with Base R ---------------------------------------------------------------
# Choices: secs, mins, hours, days
normalDate_later - normalDate %>% as.numeric("secs") 
normalDate_later - normalDate %>% as.numeric("mins")
normalDate_later - normalDate %>% as.numeric("hours")
normalDate_later - normalDate %>% as.numeric("days")

leapYear_later - leapYear %>% as.numeric("days") # Note this is 3 days because of leap year
enterDST_later - enterDST %>% as.numeric("days")
exitDST_later - exitDST %>% as.numeric("days")

## TAKEAWAY: All methods are fine for calculating physical time differences in units less than a week. Do not use units greater than a week if the goal is precision.

## Units higher than week -------------------------------------------------------------------
# There may be times when you need to use units higher than a week. For example, you might wonder
# how old a meter is in months or years. In these cases, just realize that it doesn't mean much to say how 
# old something is in those units, because they change depending on the year.

# An example to make the point

normalFebStart <- as_date("2014-02-01")
normalFebEnd <- as_date("2014-03-01")
leapFebStart <- as_date("2016-02-01")
leapFebEnd <- as_date("2016-03-01")

(normalFebEnd - normalFebStart) %>% time_length("month")
(leapFebEnd - leapFebStart) %>% time_length("month")
as.duration(normalFebEnd - normalFebStart) %>% time_length("month")
as.duration(leapFebEnd - leapFebStart) %>% time_length("month")
interval(normalFebStart, normalFebEnd) %>% time_length("month")
interval(leapFebStart, leapFebEnd) %>% time_length("month") # Notice this is "correct", but not necessarily accurate. We know that this month is 29 days, but the previous month was 28 days. Why is the answer the same? A human would be happy, but a robot would be mad.
```

### Extracting Components
```{r}
normalDate <- as_date("2014-02-28")

mday(normalDate)
wday(normalDate)
wday(normalDate, label = TRUE)
wday(normalDate, label = TRUE, abbr = FALSE)
month(normalDate)
month(normalDate, label = TRUE)
month(normalDate, label = TRUE, abbr = FALSE)
year(normalDate)
```

### Common Tasks
**Buffer audit period**
```{r}
auditStart <- as_date("2016-05-01") # Notice this is a leap year
auditEnd <- as_date("2017-04-30")

## WARNING: This works here because we are only working with dates, 
## but it will cause headaches when time is involved
auditStart - months(2)
auditEnd + months(2) 

## CORRECT
auditStart %m-% months(2)
auditEnd %m+% months(2) 
```

**Create a sequence of dates**
```{r}
testStart <- as_date("2016-02-01") # Notice this is a leap year
testEnd <- as_date("2017-04-30")
```

**Plot event in month, regarldess of year**
```{r}

```

# Formatting for labels {.tabset .tabset-fade}
## Common
```{r}

```

## Advanced Labels
```{r}

```

## Base R
```{r}

```

